---
title: "Assignment 5"
author: "T Xu"
date: "Wednesday, October 01, 2014"
output: html_document
---

Getting the financial data
--------------------
In this lab, you will learn more about the analysis of stock returns by using the R packages PerformanceAnalytics, zoo and tseries (click them for more information).
In this first exercise, you will use the get.hist.quote function from the tseries package. The function allows you to download historical financial data over the web. The code on the right downloads the adjusted closing prices from the start of 1998 up to the end of 2009 from Yahoo! for the stocks with tickers VBLTX and FMAGX. The code further specifies that the data should be of the zoo class which is indexed by time. Since we deal with monthly data, it is a good idea to change the class of the time series index with the as.yearmon function
```{r}
# Load relevant packages
library(PerformanceAnalytics);library(zoo);library(tseries);

# Get the monthly adjusted closing price data on VBLTX, FMAGX and SBUX from Yahoo! using the tseries function get.hist.quote(). Set the sample to Jan 1998 through Dec 2009.

# Get the adjusted closing prices from Yahoo!
VBLTX_prices = get.hist.quote(instrument="vbltx", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")

FMAGX_prices = get.hist.quote(instrument="fmagx", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")

SBUX_prices = get.hist.quote(instrument="sbux", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")

# Change the class of the time index to yearmon which is appropriate for monthly data
# index() and as.yearmon() are functions in the zoo package  

index(VBLTX_prices) = as.yearmon(index(VBLTX_prices))
index(FMAGX_prices)  = as.yearmon(index(FMAGX_prices))
index(SBUX_prices)   = as.yearmon(index(SBUX_prices))

# Inspect your data
start(VBLTX_prices)
end(VBLTX_prices) 
```

Calculating the returns
-------------------------
In the previous exercise, we obtained the price series for multiple stocks. It is convenient to store these time series in a single variable before we start the analysis. You will use the merge function to do that, since it merges series by column while taking into account the time index.
Remember that the continuously compounded returns are defined as the difference between the log prices. Once all price series are merged by column, you can easily calculate the continuously compounded returns. Use the log function to calculate the log prices and apply the diff function to the object that contains the log prices to get the continuously compounded returns.
```{r}
# The variables VBLTX_prices, FMAGX_prices and SBUX_prices are preloaded in your workspace

# Create merged price data
all_prices = merge(VBLTX_prices,FMAGX_prices,SBUX_prices)
# Rename columns
colnames(all_prices) = c("VBLTX", "FMAGX", "SBUX")

# Calculate cc returns as difference in log prices
all_returns = diff(log(all_prices))

# Look at the return data
start(all_returns)
end(all_returns)
colnames(all_returns) 
head(all_returns)
```
Plotting financial data with PerformanceAnalytics
---------------------------------
The PerformanceAnalytics package implements a collection of econometric functions for performance and risk analysis. It contains - among other things - functionality to generate great plots of financial time series. You will use some of that functionality in this exercise. Find an overview of the plotting functionality in the package here.
The chart.TimeSeries function generates a line plot of (multiple) return series, which allows you to assess the volatility of different assets, for example. While this is nice, charts generated by chart.TimeSeries could be hard to read when you evaluate the returns. The PerformanceAnalytics function chart.Bar makes it easier to compare the returns of different assets on the same plot. Click 'Submit Answer' and use the arrows to compare the two plots. With all assets on the same scale, you see the lower volatility for the bond fund and the higher volatility for SBUX very clearly.
Lastly, have a look at the chart.CumReturns function which creates a cumulative return plot. It allows you to assess how a $1 investment in each asset evolved over time.
```{r}
# 'all_returns' is preloaded in your workspace.

# Plot returns after using the PerformanceAnalytics function chart.TimeSeries().
# This function creates a slightly nicer looking plot than plot.zoo()
chart.TimeSeries(all_returns, legend.loc="bottom", main=" ") 

# The previous charts are a bit hard to read. The PerformanceAnalytics function
# chart.Bar makes it easier to compare the returns of different assets on the 
# same plot
chart.Bar(all_returns, legend.loc="bottom", main=" ")


# Cumulative return plot - must use simple returns (!) and not cc returns for this
# Use PerformanceAnalytics function chart.CumReturns()
simple_returns = diff(all_prices)/lag(all_prices, k=-1);
chart.CumReturns(simple_returns,wealth.index=TRUE,legend.loc="topleft",main="Future Value of $1 invested")
```

Create graphical summary for a return series
---------------------------------------
As a first step, the code on the right extracts the "core data" from the "all_returns" variable and stores it in the matrix return_matrix. "Extracting the core data" in this case means stripping off the index/time attributes and returning only the observations. Secondly, the graphical window is subdivided into two rows and two columns with the par(mfrow=c(2,2,)) command. Finally, the code generates a histogram, boxplot, density and qqplot of the return data. This allows you to visually assess the symmetry of the return distribution, whether or not there are fat tails, outliers, etc.
```{r}
# Create matrix with returns
return_matrix = coredata(all_returns);

# Generate four panel plots
par(mfrow=c(2,2))
hist(return_matrix[,"VBLTX"],main="VBLTX monthly returns",
     xlab="VBLTX", probability=T, col="slateblue1")
boxplot(return_matrix[,"VBLTX"],outchar=T, main="Boxplot", col="slateblue1")
plot(density(return_matrix[,"VBLTX"]),type="l", main="Smoothed density",
     xlab="monthly return", ylab="density estimate", col="slateblue1")
qqnorm(return_matrix[,"VBLTX"], col="slateblue1")
qqline(return_matrix[,"VBLTX"])
par(mfrow=c(1,1))
```

Return distribution comparison
-----------------------------
While the plot in the previous exercise allowed you to investigate the returns of a single stock, it is often of interest to compare several return series with each other. The code on the right does that by generating three boxplots that use the standard boxplot function from base R. While that is okay, the PerformanceAnalytics package offers you the more convenient chart.Boxplot function.
```{r}
# Create matrix with returns
return_matrix = coredata(all_returns);

# Show boxplot of three series on one plot
boxplot(return_matrix[,"VBLTX"], return_matrix[,"FMAGX"], return_matrix[,"SBUX"],
        names=colnames(return_matrix), col="slateblue1")

# Do the same thing using the PerformanceAnalytics function chart.Boxplot
chart.Boxplot(all_returns)
```
Compute univariate descriptive statistics
-----------------------
Having the returns in a matrix (return_matrix) allows you to compute several descriptive statistics for each return series with the apply function. The apply function takes three elements as input:
An array (in this case a matrix) on which you want to "apply" a certain function.
The subscripts which the function will be applied over. E.g. for a matrix 1 indicates rows, and 2 indicates columns.
The function to be applied. The code on the right computes for example the mean, the variance and the standard deviation for each return series.
The PerformanceAnalytics package offers you specific descriptive statistics that are useful for returns: e.g. skewness and kurtosis. Furthermore, the package offers one simple function, table.Stats, that takes the return series as input and returns a table with numerous useful descriptive statistics.
```{r}
# Note: all_returns is preloaded in your workspace

# Create matrix with returns
return_matrix = coredata(all_returns);

summary(return_matrix)

# Compute descriptive statistics by column using the base R function apply()
args(apply)
apply(return_matrix, 2, mean)
apply(return_matrix, 2, var)
apply(return_matrix, 2, sd)
apply(return_matrix, 2, skewness)
apply(return_matrix, 2, kurtosis)
# A nice PerformanceAnalytics function that computes all of the relevant descriptive statistics is table.Stats
table.Stats(all_returns)
```
Annualized monthly estimates
---------------------------------
Remember that the returns in return_matrix were continuously compounded. Therefore, an estimate of the annual continuously compounded return is just 12 times the monthly continuously compounded return. An estimate of the continuously compounded annual standard deviation is the square root of 12 times the monthly standard deviation.
For the three assets we can use the apply function again to calculate their respective means and standard deviations, and then apply the correct transformation. Your task is to complete the code on the right. The calculation for the simple return is given to get you started!
```{r}
# Note: return_matrix is preloaded in your workspace

# Annualized continuously compounded mean 
12*apply(return_matrix, 2, mean);

# Annualized simple mean
exp(12*apply(return_matrix, 2, mean)) - 1;

# Annualized standard deviation values
sqrt(12)*apply(return_matrix, 2, sd);
```
Bivariate graphical analysis
----------------------
A graphical analysis can often help you to get a grasp on the co-movement between financial assets. The pairs function generates all possible pair-wise scatter plots between series.
To get a more formal grasp on the co-movement between assets, the covariance and correlation matrix of the returns can be computed by applying the var and cor on the return_matrix.
```{r}
# Note: return_matrix is preloaded in your workspace

# Display all possible pair-wise scatter plots

pairs(return_matrix, col="slateblue1", pch=16)


# Compute 3 x 3 covariance and correlation matrices
var(return_matrix)
cor(return_matrix)
```

Question 1
------------------
(10) Which of the following has the greatest volatility over the 1998 - 2009 time period?

* Starbucks stock

Question 2
-------------------------
(10) Which of the following was least affected by the crisis in 2008?
* Vanguard long term bond index fund

Question 3
----------------
(10) Which asset performed the worst over the investment horizon?
* Fidelity Magellan stock mutual fund

Question 4
----------------------
(12) Based on the panel plot you created for VBLTX, check all that apply.
* Approximately symmetric
* Fatter tails than normal distribution
* Outliers

Question 5
------------------------
(10) Based on the summary statistics, which asset is the most skewed?
```{r}
apply(return_matrix, 2, skewness)
```
* Fidelity Magellan stock mutual fund

Question 6
---------------------------
(10) What is the estimated annual standard deviation for Starbucks?
```{r}
# Annualized standard deviation values
sqrt(12)*apply(return_matrix, 2, sd);
```

Question 7
------------------

(10) Which two assets show the strongest positive linear association?
* FMAGX:SBUX

Question 8
------------------
(10) Do the monthly cc returns for any of the assets
appear to be correlated over time?
* No
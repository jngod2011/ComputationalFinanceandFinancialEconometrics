{
    "contents" : "---\ntitle: \"Programming Assignment 6\"\nauthor: \"T Xu\"\ndate: \"Wednesday, October 15, 2014\"\noutput: html_document\n---\n\nDownload the data and calculate the returns\n---------------------------\nDo you still remember from the last lab how to download financial data using the get.hist.quote function from the tseries package? Have a look at the code on the right as a recap.\nIt downloads the data and changes the class of the time index of the three price series to \"yearmon\".\nThe three price series are merged into the all_prices variable.\nThe continuously compounded returns are computed and assigned to the variable all_returns.\nFinally, all return data is also stored in the return_matrix variable.\n```{r}\nlibrary(tseries)\nlibrary(zoo)\nVBLTX_prices = get.hist.quote(instrument=\"vbltx\", start=\"2005-09-01\", end=\"2010-09-30\", quote=\"AdjClose\",provider=\"yahoo\", origin=\"1970-01-01\",compression=\"m\", retclass=\"zoo\")\nFMAGX_prices = get.hist.quote(instrument=\"fmagx\", start=\"2005-09-01\", end=\"2010-09-30\", quote=\"AdjClose\",provider=\"yahoo\", origin=\"1970-01-01\",compression=\"m\", retclass=\"zoo\")\nSBUX_prices = get.hist.quote(instrument=\"sbux\", start=\"2005-09-01\",end=\"2010-09-30\", quote=\"AdjClose\",provider=\"yahoo\", origin=\"1970-01-01\",compression=\"m\", retclass=\"zoo\")\n\n# Change the class of the time index to yearmon, which is appropriate for monthly data.\n# index() and as.yearmon() are functions in the zoo package \nindex(VBLTX_prices) = as.yearmon(index(VBLTX_prices))\nindex(FMAGX_prices) = as.yearmon(index(FMAGX_prices))\nindex(SBUX_prices) = as.yearmon(index(SBUX_prices))\n\n# Create merged price data\nall_prices = merge(VBLTX_prices, FMAGX_prices, SBUX_prices)\n# Rename columns\ncolnames(all_prices) = c(\"VBLTX\", \"FMAGX\", \"SBUX\")\n\n# Calculate cc returns as difference in log prices\nall_returns = diff(log(all_prices))\n\n# Create matrix with returns\nreturn_matrix = coredata(all_returns)\n```\n\nThe standard error of the variances\n-------------------------\nConsider the constant expected return model (CER):\nRit=μi+ϵit, t=1,…,T\nϵit ~ iid N(0,σ2i)\ncov(ϵit,ϵjt)=σij,\nwhere Rit denotes the continuously compounded return on asset i, with i= Vanguard long term bond index fund (VBLTX), Fidelity Magellan stock mutual fund (FMAGX), Starbucks stock (SBUX). The model thus assumes that the returns of these assets are normally distributed and that the time series of these continuously compounded returns are covariance stationary.\nThe parameters of the above CER model are of course unknown to us. It is your task now to estimate the model parameters σ2i for the different assets. The data that you constructed in the previous exercise is given. Remember from the course that an estimator for σ2i is just the sample variance.\nOnce you have these estimates, your second task is to investigate the precision of the estimates. More specifically, you should estimate the standard errors in order to get SE^(σ2i^).\nThe formula is given by: SE^(σ2i^)=σ2i^/(T/2−−−√).\n```{r}\n# The variable return_matrix is preloaded in your workspace\n\n# Number of observations\nn_obs = dim(return_matrix)[1]\n\n# Estimates of sigma2hat\nsigma2hat_vals = apply(return_matrix, 2, var)\n\n# Standard Error of sigma2hat\nse_sigma2hat = sigma2hat_vals/sqrt(n_obs/2)\nse_sigma2hat \n\n```\n\nEstimate the standard error of the correlation parameter\n------------------------\nStill consider the constant expected return model (CER) introduced in the previous exercise. Correlations indicate the strength of the dependency between two variables. You are now interested in estimates of the correlations ρij between the returns of the different assets i and j. Furthermore, you would like to investigate the precision of these estimates by calculating the standard error of ρ^ij, which will be used for inference in later exercises.\nRecall that the estimated SE values are computed using the analytic formula: SE^(ρij^)=(1−ρij^2)/T−−√.\n```{r}\n#Calculate the correlation matrix\ncor_matrix = cor(return_matrix)\n\n# Get the lower triangular part of that 'cor_matrix'\nrhohat_vals = cor_matrix[lower.tri(cor_matrix)]\n\n# Set the names\nnames(rhohat_vals) <- c(\"VBLTX,FMAGX\",\"VBLTX,SBUX\",\"FMAGX,SBUX\")\n\n# Compute the estimated standard errors for correlation\nse_rhohat = (1-rhohat_vals^2)/sqrt(dim(return_matrix)[1])\n\nse_rhohat\n```\nHypothesis test for the mean\n-----------------------------\nStill consider the constant expected return model (CER) that was introduced in exercise 2.\nYou would like to test for each μi (i= VBLTX, FMAGX and SBUX):\nH0:μi=0 vs. H1:μi≠0, using a 5% significance level. In other words, you would like to investigate whether the mean return is significantly different from zero according to the data. Perform the test using the t-statistic as well as the 95% confidence. You can use the R function t.test() for this problem.\n```{r}\n# The \"all_returns\" zoo object is preloaded in your workspace\nt.test(all_returns[,\"SBUX\"])\nt.test(all_returns[,\"VBLTX\"])\nt.test(all_returns[,\"FMAGX\"])\n```\nHypothesis test for the correlation\n------------------------------------\nStill consider the constant expected return model (CER) that was introduced in exercise 2.\nYou would like to test for each ρij (ij= \"VBLTX,FMAGX\", \"VBLTX,SBUX\" and \"FMAGX,SBUX\"):\nH0:ρij=0 vs. H1:ρij≠0, using a 5% significance level. In other words, you would like to investigate whether the correlation between two return series is significantly different from zero according to the data. Perform the test for correlation between paired samples at the 95% confidence level. You can use the R function cor.test() for this problem.\n```{r}\n# The \"all_returns\" zoo object is preloaded in your workspace\n\n# Test the correlation between VBLTX,FMAGX\ncor.test(x=all_returns[,\"VBLTX\"], y=all_returns[,\"SBUX\"])\ncor.test(x=all_returns[,\"FMAGX\"], y=all_returns[,\"SBUX\"])\ncor.test(x=all_returns[,\"VBLTX\"], y=all_returns[,\"FMAGX\"])\n```\n\nNormality of the asset returns\n-------------------------------\nRemember that the Constant Expected Return model assumes that returns are normally distributed. Is that a reasonable assumption? The Jarque Bera test provides a way to answer that question. You can easily perform the Jarque Bera test for normality in R with the jarque.bera.test function.\nLet us say that you want to investigate whether it is reasonable that the returns of VBLTX are normally distributed. More formally, you would like to test the null hypothesis:\nH0:rit ~ normal vs. H1:rit ~ not normal using a 5% significance level, with $i=$VBLTX.\n```{r}\n# The \"all_returns\" zoo object is preloaded in your workspace\n\n# Test the normality of the returns of VBLTX\njarque.bera.test(all_returns[,\"VBLTX\"])\njarque.bera.test(all_returns[,\"SBUX\"])\njarque.bera.test(all_returns[,\"FMAGX\"])\n```\nBootstrapping\n-------------------------\nIn the previous exercise you rejected the null hypothesis that the returns were drawn from a normal distribution. In this exercise we will investigate the distribution of the estimator for the mean return, without making assumptions about the distribution of the returns and by using the technique called \"bootstrapping\"\" that was introduced during the course.\nIn the code on the right, the function mean_boot is defined. It estimates the mean of the bootstrapped samples. It takes as first element the data (in this case the return series). As a second argument, it takes a vector that is used to scramble the data before estimating the mean. The output of the function is then the mean value that is computed by using resampled data.\nIn R, the boot package offers the boot function for convenient bootstrapping. As a first argument, you should supply the data. As a second argument, the function used to estimate the parameter of interest (the mean_boot function in this case) and as a third argument, the number of bootstrap samples that you would like to create. The output of the function should be an object of the class \"boot\".\nThis is the final exercise of this lab on DataCamp. If you would like to explore this topic more in depth, you can certainly have a look at \"lab7.R\" under the resources tab on Coursera.\n```{r}\nlibrary(\"boot\")\n# Function for bootstrapping sample mean: \nmean_boot = function(x, idx) {\n  ans = mean(x[idx])\n  ans \n} \n# Construct VBLTX_mean_boot:\nVBLTX_mean_boot = boot(return_matrix[,\"VBLTX\"], statistic = mean_boot, R=999)\n# Print the class of VBLTX_mean_boot\nclass(VBLTX_mean_boot)\n\n# Print VBLTX_mean_boot\nVBLTX_mean_boot\n\n# Plot bootstrap distribution and qq-plot against normal\nplot(VBLTX_mean_boot)\n```\n\n\n\n\n\n\n",
    "created" : 1413408853748.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1829194517",
    "id" : "1237FD63",
    "lastKnownWriteTime" : 1413412233,
    "path" : "~/GitHub/ComputationalFinanceandFinancialEconometrics/Assignment7/ProgrammingAssignment6.Rmd",
    "project_path" : "ProgrammingAssignment6.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}
{
    "contents" : "---\ntitle: \"Lab 8 - Computing efficient portfolios using matrix algebra\"\nauthor: \"T Xu\"\ndate: \"Friday, October 31, 2014\"\noutput: html_document\n---\nLoading in your data set\n\nIn this final lab you continue your exploration of portfolio theory. Let us first load the data set returns_df into the workspace. This data set contains the monthly returns on the Boeing, Nordstrom, Starbucks and Microsoft stock from March 1995 up to January 2000.\nYou can find the data set at http://s3.amazonaws.com/assets.datacamp.com/course/compfin/lab9.RData.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# Load the relevant packages\nlibrary(\"zoo\")\n\n# Load the working environment\nload(url(\"http://s3.amazonaws.com/assets.datacamp.com/course/compfin/lab9.RData\"))\n\n# Explore the data set\nhead(returns_df)\ntail(returns_df)\n\n# Timeplots with stocks on individual graphs\nmy.panel <- function(...) {\n  lines(...)\n  abline(h=0)\n}\nplot(returns_df, lwd=2, panel=my.panel, col=\"blue\")\n\n# Timeplots with stocks on same graph\nplot(returns_df, plot.type = \"single\", main=\"Returns\", col=1:4, lwd=2)\nabline(h=0)\nlegend(x=\"bottomleft\", legend=colnames(returns_df), col=1:4, lwd=2)\n\n```\n\nThe CER model\n\nBefore diving into the actual arithmetics, you first need to calculate the parameters of the constant expected return model (CER). Make use of the data in returns_df to estimate the model parameters for all four stocks.\n```{r}\n# All data is preloaded in your workspace.  Type 'ls()' in the console to see what has been loaded.\n\n# Parameters CER model\nmu_hat_month = apply(returns_df, 2, mean)\nmu_hat_month\nsigma2_month = apply(returns_df, 2, var)\nsigma2_month\nsigma_month = apply(returns_df, 2, sd)\nsigma_month\ncov_mat_month = var(returns_df)\ncov_mat_month\ncor_mat_month = cor(returns_df)\ncor_mat_month\n\n# Pairwise scatterplots\npairs(coredata(returns_df), col=\"blue\", pch=16)\n\n```\n\nThe global minimum variance portfolio - Part One\n\nIn the previous lab you already determined the global minimum variance portfolio if short sales are allowed.\nLet us do a quick recap here: use globalMin.portfolio() to calculate the global minimum variance portfolio for your four stocks when you are allowed to take short positions.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# Calculate the global minimum variance portfolio\nglobal_min_var_portfolio = globalMin.portfolio(mu_hat_month, cov_mat_month,shorts=TRUE)\n\nglobal_min_var_portfolio\n\n# Plot the portfolio weights of our four stocks\nplot(global_min_var_portfolio)\n```\n\nThe global minimum variance portfolio - Part Two\n\nNow you want to construct the global minimum variance portfolio under the condition that short sales are not allowed. The Markowitz portfolio optimization problem for the minimum variance portfolio with no short sales restrictions can be described as follows:\n\nminx σ2p,x=x′∑x s.t. \nx′1=1 \nxi≥0, \nwith x the vector of portfolio weights, σ2p,x and μp,x the portfolio variance and expected return respectively, μ the vector of expected returns and Σ the covariance matrix of the returns.\nAs seen in the lectures, the portfolio optimization problem with inequality constraints can be set up as a quadratic programming problem. Quadratic programming problems are of the form:\n\nminx 12x′Dx−d′x \nA′neqx≥bneq for m inequality constraints, and \nA′eqx=bneq for l equality constraints, \nwhere D is a n×n matrix, x and d are n×1 vectors, A′neq is an m×n matrix, bneq is an m×1 vector, A′eq is an l×n matrix, and beq is an l×1 vector.\nQuadratic programming problems can be solved with the R package quadprog and the solve.QP() function. In the next exercise you will discover a more easy way to do this with the help of globalMin.portfolio().\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# set restriction matrices\nD_matrix = 2* cov_mat_month\nD_matrix\nd_vector = rep(0,4)\nd_vector\nA_matrix = cbind(rep(1,4),diag(4))\nA_matrix\nb_vector = c(1,rep(0,4))\nb_vector\n\n# use solve.QP to minimize portfolio variance\nlibrary(quadprog)\nquad_prog = solve.QP(Dmat = D_matrix,dvec = d_vector, Amat = A_matrix, bvec = b_vector, meq = 1) \nquad_prog\n```\n\n\nThe global minimum variance portfolio - End game\n\nEven though the previous exercise provided a good insight in the calculation of a global minimum variance portfolio when short sales are not allowed, this way of working is somewhat complex.\nOne of the great things of R is that you can \"hide\" this complexity in a function and/or package. You provide the input to the function via its arguments, and R does the rest.\nSo instead of calculating the global minimum variance portfolio via the solve.QP() function, you can also use globalMin.portfolio() function.globalMin.portfolio() has an argument shorts and if you set this argument equal to FALSE, short sales are not allowed. In the background it is still solved as a quadratic programming problem, but as a user you are spared from these underlying details.\nYou can always check the underlying code of the function by typing globalMin.portfolio in the console.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# The global minimum variance portfolio\nglobal_min_var_portfolio  = globalMin.portfolio(mu_hat_month, cov_mat_month, shorts=FALSE)\n\nglobal_min_var_portfolio \n```\n\nAn efficient portfolio\n\nYou need to construct an efficient portfolio that uses the maximum average return as the target return.\nConsider two different scenarios: a scenario where short selling is allowed, and a scenario where short selling is forbidden. The minimization problem if short selling is allowed is: \nminm σ2p=x′∑x s.t. \nx′μ=μ0 \nx′1=1, with μ0 the target return and other symbols as defined before.\nIf you do not allow for short sales, the following constraint is added: \nxi≥0 for all i.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# highest average return\nmu_target = max(mu_hat_month)\n\n# short sales allowed\nefficient_porfolio_short = efficient.portfolio(mu_hat_month, cov_mat_month, mu_target,shorts=TRUE)\nefficient_porfolio_short\nplot(efficient_porfolio_short)\n\n# no short sales allowed\nefficient_porfolio_no_short = efficient.portfolio(mu_hat_month, cov_mat_month, mu_target,shorts=FALSE)\nefficient_porfolio_no_short\nplot(efficient_porfolio_no_short)\n```\n\nThe efficient frontier\n\nUsing the fact that all efficient portfolios can be written as a convex combination of two efficient portfolios, you can compute efficient portfolios as convex combinations of the global minimum variance portfolio and the efficient portfolio calculated in the previous exercise: \nz=α∗m+(1−α)∗x for values of α being between −1 and 1, with m the vector of portfolio weights of the global minimum variance portfolio and with x the vector of portfolio weights of the efficient portfolio that was calculated in the previous exercise.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# The efficient frontier of risky assets \nefficient_frontier = efficient.frontier(mu_hat_month, cov_mat_month, alpha.min=-1, alpha.max=1)\nsummary(efficient_frontier)\n\n# The plot\nplot(efficient_frontier, plot.assets=TRUE, col=\"blue\", lwd=2)  \n\n```\n\nThe tangency portfolio\n\nLet us see how the weights of the underlying assets of the tangency portfolio depend on whether or not short positions are allowed.\nAssume the risk-free rate is 0.005 (rf = 0.5%) per month. The tangency portfolio can be found via: \nmaxt slope = μp−rfσp subject to \nμp=t′μ \nσp=(t′∑t)1/2 \nt′1=1, \nwith μp and σp the portfolio return and standard deviation respectively, t the vector of portfolio weights, μ the vector of expected returns and Σ the covariance matrix of the returns.\nIf you add the condition that no short positions are allowed, the additional constraint that is to be added is xi≥ for i=1,…,4.\nLuckily, the underlying arithmetics are encapsulated in the R function tangency.portfolio(). Again, smart use of these functions can make your work as a financial analyst considerably lighter.\n```{r}\n# All data and CER parameters are preloaded in your workspace.  Type 'ls()' in the console to see them.\n\n# risk free rate\nt_bill_rate = 0.005\n\n# Tangency portfolio short sales allowed\ntangency_portfolio_short = tangency.portfolio(mu_hat_month, cov_mat_month, risk.free=t_bill_rate,shorts=TRUE)\nsummary(tangency_portfolio_short)\n#plot\nplot(tangency_portfolio_short)\n\n# Tangency portfolio short sales not allowed\ntangency_portfolio_no_short = tangency.portfolio(mu_hat_month, cov_mat_month, risk.free=t_bill_rate,shorts=FALSE)\nsummary(tangency_portfolio_no_short)\n#plot\nplot(tangency_portfolio_no_short)\n\n```\n\n\nQuestion 1\n(10) Which two assets have the highest correlation?\n```{r}\ncor_mat_month\n```\n\nQuestion 2\n(10) What is the weight of Microsoft in the global minimum variance portfolio?\n```{r}\nglobal_min_var_portfolio$weights\n```\n\nQuestion 3\n(10) What is the standard deviation of the global minimum variance portfolio?\n```{r}\nglobal_min_var_portfolio$sd\n```\n\nQuestion 4\n(10) What is the expected return of the global minimum variance portfolio?\n```{r}\nglobal_min_var_portfolio$er\n```\n\nQuestion 5\n(10) What happens to the global minimum variance portfolio if short sales are restricted?\nno change\n\nQuestion 6\n(10) Of the four stocks, determine the stock with the largest estimated expected return. Use this maximum average return as the target return for the computation of an efficient portfolio allowing for short-sales. What is the weight of Microsoft in this portfolio?\n```{r}\nefficient.portfolio(mu_hat_month, cov_mat_month, mu_target,shorts=TRUE)\n```\n\nQuestion 7\n(10) Of the four stocks, determine the stock with the largest estimated expected return. Use this maximum average return as the target return for the computation of an efficient portfolio not allowing for short-sales. What is the weight of Microsoft in this portfolio?\n```{r}\nefficient.portfolio(mu_hat_month, cov_mat_month, mu_target,shorts=FALSE)\n```\n\nQuestion 8\n(10) Using the fact that all efficient portfolios can be written as a convex combination of two efficient portfolios, compute efficient portfolios as convex combinations of the global minimum variance portfolio and the efficient portfolio that was computed in question six. What is the expected return of the portfolio when α=.5?\n```{r}\n\n```\n\nQuestion 9\n(10) What is the weight of Microsoft in the tangency portfolio with short sales allowed?\n```{r}\ntangency_portfolio_short$weights\n```\n\nQuestion 10\n(10) What is the weight of Microsoft in the tangency portfolio with short sales not allowed?\n```{r}\ntangency_portfolio_no_short$weights\n```",
    "created" : 1414775493117.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2208256646",
    "id" : "6F11D1CE",
    "lastKnownWriteTime" : 1414777105,
    "path" : "~/GitHub/ComputationalFinanceandFinancialEconometrics/Assignment9/ProgrammingAssignment9.Rmd",
    "project_path" : "ProgrammingAssignment9.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}